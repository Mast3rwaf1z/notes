
%--------------------------------------------------------------------
%                            Preample
%--------------------------------------------------------------------

\documentclass[aspectratio=1610,17pt,utf8]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[USenglish]{babel}
\usepackage{graphicx} % graphics
\usepackage{mathabx}
\usepackage{mathpazo}
\usepackage{eulervm}


% title slide definition
\title[DS]{Distributed Systems}
\subtitle{Exam}
\author[Thomas Møller Jensen]{Thomas Møller Jensen}
\institute[Institute of Computer Science]
{
  Aalborg University\\
}

%--------------------------------------------------------------------
%                            Titlepage
%--------------------------------------------------------------------

\begin{document}

%-------------------------------------------------------------------
%                            Content
%-------------------------------------------------------------------
%                 Distributed Mutual Exclusion
%-------------------------------------------------------------------

\begin{frame}{Distributed Mutual Exclusion}
    What is a mutex? Kinda a Lock for distributed systems \ldots

    In a distributed system a mutex is for locking a shared resource in a network, traditionally in a program, a lock would be enough to handle concurrent writes/reads, but when the communication is expensive, locking the resource is harder to do.
\end{frame}

\begin{frame}{Mutex Algorithms}
    \section{Mutex algorithms}
    \begin{itemize}
        \item Centralized Algorithm
        \item Token Ring Algorithm
        \item Ricart and Agrawala's algorithm
        \item Maekawas algorithm
    \end{itemize}
\end{frame}

\begin{frame}{Centralized algortihm}
    \begin{minipage}{.45\textwidth}
        \begin{figure}
            \includegraphics[width=\textwidth]{figures/1-mutex.png}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.5\textwidth}
        \tiny{All three nodes highlighted are points of failure.}
    \end{minipage}
\end{frame}

\begin{frame}{Token Ring Algorithm}
    \begin{minipage}{.45\textwidth}
        \begin{figure}
            \includegraphics[width=\textwidth]{figures/1-token.png}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.5\textwidth}
        \tiny{All nodes are points of failure at any given time.}
    \end{minipage}
\end{frame}

\begin{frame}{Ricart and Agrawala's algorithm}
    \begin{minipage}{.45\textwidth}
        \begin{figure}
            \includegraphics[width=\textwidth]{figures/1-ricart-agrawala.png}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.5\textwidth}
        \tiny{All requests are multicast.\\There is a 4th step where a release is multicast to all nodes as well.\\All nodes are points of failure at any given time.}
    \end{minipage}
\end{frame}

\begin{frame}{Maekawas algorithm}
    \begin{minipage}{.45\textwidth}
        \begin{figure}
            \includegraphics[width=\textwidth]{figures/1-maekawa.png}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.5\textwidth}
        \tiny{Very similar to Ricart and Agrawala, but only nodes in the subset failing will result in a particular node to fail. If you're a bit smart about choosing the subsets this can be minimized.}
    \end{minipage}
\end{frame}

\begin{frame}{Performance}
    Bandwidth means Entry and Exit potential. This means how many times an acces can happen per messages.\\
    Token ring is infinite because the node itself chooses when to send the token.\\
    Ricart and Agrawala's algorithm has a bandwidth of 1+n-1 if it can do multicast in hardware, otherwise its n-1+n-1, as it will now have to unicast to everyone.
    \tiny{\begin{table}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            Algorithm & Entry & Exit & sync & Bandwidth \\\hline
            Centralized & 2 & 1 & 2 & 2 / 1 \\\hline
            Token Ring & a:n/2 w:n-1 & 1 & a:n/2 w:n-1 & $\infty$ / 1 \\\hline
            R + A & 2 & 2 & 1 & 1+n-1 or n-1+n-1 / n-1 \\\hline
            maekawa & 2 & 1 & 2 & $4 \sqrt{n}-2$ / $2 \sqrt{n}-1$ \\\hline
        \end{tabular}
    \end{table}}
\end{frame}
%-------------------------------------------------------------------
%                 Multicast/Group Communication
%-------------------------------------------------------------------

\begin{frame}{Multicast/Group Communication}

    \begin{figure}
        \includegraphics[width=1\textwidth]{figures/2-multicast-group.png}
    \end{figure}
\end{frame}

\begin{frame}{IP Multicast - Hardware Support}
    Uses a protocol called IGMP

    If there's hardware support, the sender transmits one message and the intermediary devices will determine how many devices it will transmit the message to.\\
    If there is not hardware support, then the sender will have to unicast many messages at once to its receivers instead.
\end{frame}

\begin{frame}{IP Multicast - Problems}
    Out of order delivery, this can happen due to changes in routing. Consider a network with a slow and a fast intermediary node as two independant routes, if the sender sends a message through the slow node to the reciver followed by a message through the fast node, then the receiver might receive the second message before the first.
\end{frame}

\begin{frame}{IP Reliable Multicast}
    \begin{itemize}
        \item Trading efficiency for reliability
        \item ACKs - increases time complexity to $O(n^2)$
    \end{itemize}
\end{frame}

\begin{frame}{FIFO! First In - First Out Multicast}
    Respects sequence numbers

\end{frame}

\begin{frame}{Total Ordering}
    Two requirements must be met:
    \begin{itemize}
        \item Messages should arrive in the same order as they were sent
        \item 
    \end{itemize}
\end{frame}

\begin{frame}{Using a Sequencer}
    \begin{figure}
        \includegraphics[width=\textwidth]{figures/2-sequencer.png}
    \end{figure}
\end{frame}

\begin{frame}{Causal Ordering}
    generally, causal ordering means that the events in a network does not depend on a future event, this is usually realized using lamport clocks.


\end{frame}

\begin{frame}{Clocks for ordering}
    \begin{figure}
        \includegraphics[width=.5\textwidth]{figures/2-lamport.png}
    \end{figure}
    \begin{figure}
        \includegraphics[width=.5\textwidth]{figures/2-vector.png}
    \end{figure}
\end{frame}



%-------------------------------------------------------------------
%                     Consensus Protocols
%-------------------------------------------------------------------

\begin{frame}{Consensus Protocols}
    The idea is to make sure processes agree\\
    Synchronous Consensus Algorithm\\
    Byzantine Generals Algorithm\\
    Phase-King Algorithm
\end{frame}


\begin{frame}{Byzantine faults}
    The armies example, one half retreats, one attacks.\\
    Two different descisions was made, this is an error\\
    Byzantine failures are by extension when the whole system fails due to a byzantine fault.
\end{frame}

\begin{frame}{Correct Processes}
    A correct process is a process that is operating as expected. Closely tied with byzantine faults, if a process has a byzantine fault, then it is no longer a correct process.
\end{frame}

\begin{frame}{Synchronous Consensus Algorithm}
    f-resilience, f processes may fail
    \begin{itemize}
        \item initially multicast your value
        \item do f+1 rounds
        \item in each round, process received messages, record how many times each unique value is received
        \item multicast again
    \end{itemize}
\end{frame}

\begin{frame}{Byzantine Generals}
    > you have commanders and lieutenants, its kinda like master and slaves in other systems, the commander says a value, and the lieutenants take this value as the correct value.\\
    > In this system, if the commander is not correct, it results in a failure.\\
    > when the value is received from the commander, the lieutenants multicast their received value and id, then the majority value is chosen at each process.
\end{frame}

\begin{frame}{Phase-King algorithm}
    > generals only work for f = 1, and can be optimized\\
    f+1 phases\\
    > in each phase, all processes start by transmitting their value, if the most frequest received value is from more than half of the processes, use that value\\
    > the king is elected, process with id k is elected at phase k\\
    > the purpose of the king is to send a tie breaker if two processes share the same count of values.
\end{frame}

%-------------------------------------------------------------------
%                 Replication and Consistency
%-------------------------------------------------------------------

\begin{frame}{Replication and Consistency}
    Goal of replication:\\
    > To tolerate failures\\
    > High availability\\
    > More affordable to scale out\\
    > caching is replication
\end{frame}

\begin{frame}{Replication}
    \begin{minipage}{.45\textwidth}
        \begin{figure}
            \includegraphics[width=\textwidth]{figures/4-replication.drawio.png}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.5\textwidth}
        > each server has videos cached\\
        > if server 3 goes down, the EU user can use server 2
    \end{minipage}
\end{frame}

\begin{frame}{Passive Replication}
    > One primary node, all other nodes are backup
\end{frame}

\begin{frame}{Consistency}
    Youtube: like count is consistent while views are relaxed consistency

    What if user A and user B of a bank system adds money at the same time? all nodes has to agree on one value

\end{frame}

\begin{frame}{Sequential consistency}
    Follow causality, 
\end{frame}

%-------------------------------------------------------------------
%                     Distributed Storage
%-------------------------------------------------------------------

\begin{frame}{Distributed Storage}
\end{frame}

%-------------------------------------------------------------------
%                     Big Data Analytics
%-------------------------------------------------------------------

\begin{frame}{Big Data Analytics}
\end{frame}

%-------------------------------------------------------------------
%                         Blockchains
%-------------------------------------------------------------------

\begin{frame}{Blockchains}
\end{frame}

%-------------------------------------------------------------------
%                  Peer-to-Peer Networking
%-------------------------------------------------------------------

\begin{frame}{Peer-to-Peer Networking}
\end{frame}

%-------------------------------------------------------------------
%              Internet of Things and Routing
%-------------------------------------------------------------------

\begin{frame}{Internet of Things and Routing}
\end{frame}

\end{document}